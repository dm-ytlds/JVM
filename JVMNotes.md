JVM

JVM系列课程

## 初识JVM

### JDK、JRE、JVM之间的联系

JDK：（Java Development Kits）

​	JavaSE API太多了，从JDK8开始，出现了compact profiles，为了实现按需分配JRE的思想。从JDK9开始，在下载安装包里，就没有JRE单独的模块了，而是出现了compact profiles，分为compact1、compact2、compact3。包含在JDK安装目录的jmods目录下。可以用jlink来进行按需分配compacts。以下截图来自JDK8。

JRE：（Java Runtime Environment）

JVM：（Java Virtual Machine）

![](pics\JDK_JRE_JVM.png)

#### jdeps工具的使用

​	》jdeps即“java dependencies”，是java8提供的一个工具，在bin目录下。

​	》jdeps命令显示Java类文件的包级或类级依赖关系。输入类可以是.class文件、目录、jar文件的路径名，或者可以是完全限定的类名称，用以分析所有类文件。

​	》可以查看当前class文件依赖哪些jre文件包。

```java
例如：该class文件时对IO流文件复制的一个编译结果。在命令行运行 >jdeps -P Copy01.class的结果为：
    Copy01.class -> C:\Program Files\Java\jdk1.8.0_271\jre\lib\rt.jar (compact1)
    com.dengmin.demi.io (Copy01.class)
      -> java.io                                            compact1
      -> java.lang                                          compact1
```

#### JDK8裁剪JRE（EJDK，Embedded JDK，嵌入式版本的JDK可以实现裁剪操作）

​	》主要采用jrecreate命令完成裁剪操作；

​	》可以裁剪出JRE-compact1、JRE-compact2、JRE-compact3、JRE-Full四种JRE

### 虚拟机概念

》定义：就是一台虚拟的计算机，用来执行一系列虚拟计算机指令。

》分类：系统虚拟机和程序虚拟机。

​	系统虚拟机：对物理计算机的仿真，能够执行一整套的计算机指令。如：VM

​	程序虚拟机：如：JVM。实现一次编译，多次运行。

### JVM定义

​	》Java虚拟机是整个Java平台的基石，是Java技术实现硬件与操作系统无关的关键部分。

​	》可以看成一台抽象的计算机，有着自己的指令集以及各种运行时内存区域。

​	》Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式class文件格式所关联，class文件包含Java虚拟机指令集（或者称为字节码(bytecode)）和符号表，以及其他的一些辅助信息。

### JVM规范

​	JVM规范是官方给出的整个框架的设计和约定。不同版本之间有一些差别的，规范来自于JVM官方文档。

### JVM产品

​	不止一个，主要了解HotSpot（OracleJDK和OpenJDK默认的JVM产品）。

### JVM发展史

​	》JDK 6，出现了OpenJDK，开源的JDK，虚拟机使用的是HotSpot

​	》JDK 8，Oracle启用JEP（JDK Enhancement Proposals）来管理JDK的新特性。启用了lambda表达式，彻底移除了HotSpot的永久代

### Java资源网站

#### 学习网站

​	https://www.infoworld.com/category/java/

​	https://dzone.com/

#### 官方文档

​	JVM规范：https://docs.oracle.com/javase/specs/index.html

## Class 文件结构

### Class 文件的理解

#### Class 文件是什么

​	》Java虚拟机与Java语言没有联系，只与class文件这种特定的二进制文件格式相关联。

​	》除Java外，还有Kotlin、Clojure、Groovy、JRuby、JPython、Scala都可以编译出Class文件。

​	》Java虚拟机并不关心Class文件来自于哪种语言，Class文件中包含了Java虚拟机指令集、符号表以及若干其他的辅助信息。

#### Class文件与类的对应关系

​	》每一个class文件对应唯一的一个类或者接口的定义信息，反过来，类或者接口并不一定都必须定义在class文件里（比如，类或者接口也可以通过类加载器（classLoader，直接获取已编译好的class文件资源）直接生成）。

#### Class文件格式

​	》每个class文件都由字节流组成，每个字节包含8个二进制位，所以16位、32位、64位长度的数据将通过构造成2个、4个和8个连续的8位字节来表示。

​	》多字节数据项总是按照Big-endian（大端在前）的顺序进行存储的

- Big-endian（大端在前）：数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中。
- Little-endian（小端在前）：数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

### Class 文件的结构详述

```java
摘自官网：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];	// 常量池数组。
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
xx_info：是class文件中表的数据结构。
例如：cp_info
cp_info {
    u1 tag;
    u1 info[];
}
```

#### 什么是魔数magic

​	文件内容起始几个字节使用固定的内容来**描述该文件类型**为class文件，因此这几个字节的内容称为魔数。u4   CA FE BA BE

#### 版本号 minor_version	major_version

​	JDK6开始，就不再叫做JDK1.6了。

​	minor_version：次版本号，起始值是0

​	major_version：主版本号，起始值为45，每个JDK大版本发布，主版本号向上+1

​	JDK8（JDK1.8）的版本号为52.0（45.0 + 7 = 52.0），同理，JDK11的版本号为52.0 + 3 = 55.0

#### 常量池总数 constant_pool_count

​	》常量池大小（constant_info_count）：常量池是class文件中第一个出现的变长结构。

​	》假设常量池大小为n，常量池真正的有效索引是1~n-1。0属于保留索引，可供特殊情况使用。

#### 常量池数组 constant_pool[constant_pool_count-1]

静态常量池（很多时候说的静态常量池指的就是class文件中的常量池）。

> 常量池中主要存放两种常量：

- 字面量（Literal）
  - 字符串类型（UTF-8）、被final声明的常量值（整数值、浮点数等基本数据类型）

- 符号引用（Symbolic References）
  - 类和接口的全限定名
  - 字段的名称和描述符
  - 方法的名称和描述符
  - 方法句柄和方法类型
  - 动态调用点和动态常量

> 常量池中所有常量项的结构必包含一个tag项，tag值用于标志一个常量属于哪种常量结构。只有根据tag确定常量的结构，才能根据常量结构计算常量所占用的字节数。

> 常量池的数据结构：

```java
cp_info {
	u1 tag;	// 符号引用的编号
	u1 info[];	// 
}
```

> 根据tag的不同，JDK8中常量具体分为14种

​	常量类型表

|          Constant Type           | Value |                   描述                   |
| :------------------------------: | :---: | :--------------------------------------: |
|       CONSTANT_Class_info        |   7   |            类或接口的符号引用            |
|      CONSTANT_Fieldref_info      |   9   |              字段的符号引用              |
|     CONSTANT_Methodref_info      |  10   |            类中方法的符号引用            |
| CONSTANT_InterfaceMethodref_info |  11   |           接口中方法的符号引用           |
|       CONSTANT_String_info       |   8   |             字符串类型字面量             |
|      CONSTANT_Integer_info       |   3   |                整型字面量                |
|       CONSTANT_Float_info        |   4   |               浮点型字面量               |
|        CONSTANT_Long_info        |   5   |               长整型字面量               |
|       CONSTANT_Double_info       |   6   |            双精度浮点型字面量            |
|    CONSTANT_NameAndType_info     |  12   | 字段与字段类型或方法与方法类型的符号引用 |
|        CONSTANT_Utf8_info        |   1   |             utf-8编码字符串              |
|    CONSTANT_MethodHandle_info    |  15   |               表示方法句柄               |
|     CONSTANT_MethodType_info     |  16   |               表示方法类型               |
|   CONSTANT_InvokeDynamic_info    |  18   |          表示一个动态方法调用点          |

> 字段描述符（field descriptor）：用来表示类、实例或局部变量

| *FieldType* term    | Type        | Interpretation                                               |
| ------------------- | ----------- | ------------------------------------------------------------ |
| `B`                 | `byte`      | signed byte                                                  |
| `C`                 | `char`      | Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 |
| `D`                 | `double`    | double-precision floating-point value                        |
| `F`                 | `float`     | single-precision floating-point value                        |
| `I`                 | `int`       | integer                                                      |
| `J`                 | `long`      | long integer                                                 |
| `L` *ClassName* `;` | `reference` | an instance of class *ClassName*   类的实例方法              |
| `S`                 | `short`     | signed short                                                 |
| `Z`                 | `boolean`   | `true` or `false`                                            |
| `[`                 | `reference` | one array dimension                                          |

> 方法描述符

- 包含0个或多个参数描述符（parameter descriptor）以及多个返回值描述符（return descriptor）。参数描述符表示该方法所接受的参数类型。
- 实例方法除了传递自身定义的参数，还需要额外传递参数this，但是这一点不是由方法描述符来表达的，参数this的传递是由Java虚拟机中调用实例方法所使用的指令来实现的。

例如：方法定义对应的方法描述符示例图

![方法定义对应的方法描述符](pics\方法定义对应的方法描述符.png)

​	图例解释：

- 方法为：Object m(int i, double d, Thread t) {}
- Java虚拟机中的方法描述符为：(IDLjava/lang/Thread;)Ljava/lang/Object
- 实例方法除了传递自身定义的参数，还需要额外传递参数this，但是这一点不是由方法描述符来表达的，参数this的传递是由Java虚拟机中调用实例方法锁使用的指令来实现的。

> 常量类型具体分析

```java
1 CONSTANT_Class_info	类或接口的符号引用
	(1) 数据结构：
	CONSTANT_Class_info {
		u1 tag;	// #符号引用的编号
		u2 name_index;	// 类或接口的全限定名
	}
	(2) 名词解释
		a) 名字解释：类、接口、数组、枚举、注解的符号引用；
		b) 一个有效的数组类型描述符中描述的数组，其维度必须小于等于255；
		c) 类中或接口中使用到了其他的类，只有在类中实际使用到了该类时，该类的信息才会在常量池中有对应的CONSTANT_Class_info常量池项。
	(3) 项约束
		u2 name_index：必须是一个CONSTANT_utf8_info常量，表示类（或接口）的全限定名称。
    (4) 例子
        创建一个只包含主类的Test01.java类文件，编译后用IDEA的插件jclasslib查看类的class文件的结构，可以发现：
        	CONSTANT_Class_info的组成形式为：cp_info #常量池编号(即符号引用) <类或接口的全限定名>
    (5) 普通类、抽象类的默认父类都是Object，如果有继承关系，父类就会变成继承的那个类。也就是说，Object类是普通类和抽象类的基类。
    (6) Java面试题：Java中接口的默认父类是不是Object？
        答：Java中接口的基类不是Object。官方文档中有说到：接口中默认引用了Object类，Java的接口会隐式的实现Object中的一些方法。所以说，接口和Object的关系是关联关系，而不是继承或者实现关系。
    (7) 枚举类的基类是Object，但它的父类是Enum抽象类。创建一个枚举类，会出现四个CONSTANT_Class_info类的符号引用，其中有一个本身类，两个一维数组类和一个Enum抽象父类。
    (8) 注解(@interface)属于接口，其基类不是Object，注解的父接口是Annotation。
    
```

```java
2 CONSTANT_Fieldref_info	字段类型的符号引用
    (1) 数据结构
    CONSTANT_Fieldref_info {
    	u1 tag;	// 所属类名的符号引用（包括cp_info #标签编号），如：cp_info #4，表示该常量指向常量池中的4号常量（该常量是一个类常量符号引用）
    	u2 class_index;	// 该常量对用的类全限定名称。如：<com/demi/orders/order02/MyStu>
    	u2 name_and_type_index;	// 名字和描述符的符号引用。
	}
	(2) 名词解释（能够得到CONSTANT_Fieldref_info常量的情况）
        a) 名字解释：字段的符号引用；
        b) 所有非static final的字段；(5)(6)
        c) 所有使用的字段（何为被使用的字段？就是以下这些情况：含赋值的字段、在其他地方使用的字段、使用了其他类的字段（调用其他类的属性））。(4)(5)(6)
    (3) 项约束
        class_index：指向的常量必须是一个CONSTANT_Class_info常量，表示当前字段所在类的类名；
        name_and_type_index：指向的常量必须是一个CONSTANT_NameAndType_info常量，表示当前字段的名字和类型描述符。
    (4) 例子
        public class MyStu {
            private String id = "0001";
    		private String name;
    		private int age;
            static final int a = 33; // 没有字段符号引用CONSTANT_Fieldref_info常量
            static int b = 33; // 有字段符号引用CONSTANT_Fieldref_info
            final int c = 33; // 有字段符号引用CONSTANT_Fieldref_info
            // setter和getter省略
        }
		！！！类的属性必须在赋值后，才有字段符号引用CONSTANT_Fieldref_info出现。
	(5) 静态常量static final没有字段符号引用CONSTANT_Fieldref_info，静态变量或final修饰的变量都有字段符号引用CONSTANT_Fieldref_info。
	(6) 在类stu中创建的实例对象person，引用实例对象的非静态常量属性int age = person.pAge，在常量池中会增加三个字段符号引用：创建的实例对象引用person、实例对象的非静态常量属性引用pAge，以及该类中引用实例对象的变量age。
	(7) 方法里的局部变量没有字段符号引用常量。
```

```java
3 CONSTANT_Methodref_info	类中方法的符号引用
    (1) 数据结构
    CONSTANT_Methodref_info {
    	u1 tag;	// 符号引用的编号
    	u2 class_index;	// 方法所在的全限定类名
    	u2 name_and_type_index;	// 名字和描述符
	}
	(2) 名词解释（能出现该符号引用的情况）
        a) 名字解释：类中方法的符号引用；
        b) 所有使用的方法（何为使用？就是说必须被调用）；
        c) 默认会调用父类的无参构造方法<init>:()
```

```
4 CONSTANT_InterfaceMethodref_info	接口中方法的符号引用
	(1) 数据结构
	CONSTANT_InterfaceMethodref_info {
		u1 tag;
		u2 class_index;	// 方法所在的全限定接口名
		u2 name_and_type_index;
	}
	(2) 项约束
		> class_index：指向的常量必须是一个CONSTANT_Class_info常量，且必须是接口类型，表示当前接口方法所属的类名。
		
```

#### 常量池数组小结（前4个info）

![class文件结构图解(前4个info)](pics\class文件结构图解(前4个info).png)

#### 常量池数组续集

```
5 CONSTANT_String_info	字符串类型字面量
	(1) 数据结构
	CONSTANT_String_info {
		u1 tag;
		u2 string_index; // 常量池中某个常量的索引
	}
	(2) 可进入常量池的情况
		> static final是java语法层面上的常量，static final 修饰的字符串是class文件中的String字面量。
		> 所有出现的String类型的字面量
	(2) 项约束
		> string_index：值为常量池中某个常量的索引，该索引指向的常量必须是一个CONSTANT_utf8_info常量。
	
```

```
6 CONSTANT_Integer_info	整型字面量
	(1) 数据结构
	CONSTANT_Integer_info {
		u1 tag;
		u4 bytes;
	}
	(2) 可进入常量池的情况
		> static final修饰的所有byte char short boolean int类型都可以；
		> 可用于描述boolean(1, 0) byte(-2^7~2^7-1, 即-128~127) int short(-2^15 ~ 2^15-1, 即-32768~32767) char(0~2^16-1, 即0~65535)
		> 非final修饰，且整型值在-32768~32767（即-2^15 ~ 2^15-1，short的范围内）范围内，则直接进入字节码指令内部，超出此范围就可以得到CONSTANT_Integer_info常量。
	(3) 项约束
		>bytes：转为10进制数就是这个常量所表示的整型值。
```

```
7 CONSTANT_Float_info	浮点型字面量
	(1) 数据结构
	CONSTANT_Float_info {
		u1 tag;
		u4 bytes;
	}
	(2) 解释
		> static final是java语法层面上的常量，static final 修饰的字符串是class文件中的Float字面量。
		> 所有出现的Float类型的字面量
	(3) 项约束
		
```

##### 静态块、实例块和构造方法的执行顺序

> 静态块、实例块和构造方法的构造形式

```java
static {}称为静态块；
{}称为实例块；
public 类名(){}称为（无参）构造方法。
```

> 执行顺序测试

​	通过代码测试得出：静态代码块>实例代码块>构造方法

```
8 CONSTANT_Long_info	长整型字面量
	(1) 数据结构
	CONSTANT_Long_info {
		u1 tag;
		u4 high_bytes;
		u4 low_bytes;
	}
	(2) 解释
		> static final是java语法层面上的常量，static final 修饰的字符串是class文件中的Long字面量。
		> 所有出现的Long类型的字面量
```

```
9 CONSTANT_Double_info	双精度浮点型字面量
	(1) 数据结构
	CONSTANT_Double_info {
		u1 tag;
		u4 high_bytes;
		u4 low_bytes;
	}
	(2) 解释
		> static final是java语法层面上的常量，static final 修饰的字符串是class文件中的Double字面量。
		> 所有出现的Double类型的字面量
```

##### Fieldref_info和字面量类型常量的规则

> 何为字面量？

​	> String数据类型和基本数据类型都是字面量。

> 何为引用数据类型？

​	> 非字面量，以及基本数据类型（不包含对应的包装类）的包装类

> 得出的规则是什么？

​	> static final 修饰的字面量在本类和其他类里面都会以字面量类型的常量出现；

​	> 非static final修饰的字面量在本类以字面阿玲类型的常量出现和Fieldref_info类型的常量同时出现；

​	> 非static final修饰的字面阿玲在其他类以Fieldref_info类型的常量出现；

​	> 引用类型在本类和其他类中都会以Fieldref_info类型的常量出现。

​	> static final修饰的字面量不会以Fieldref_info类型的常量出现。

​	> static final 修饰的包装类在本类里面会出现Fieldref_info类型的常量和包装类的字面量常量；

```java
10 CONSTANT_NameAndType_info	字段与字段类型或方法与方法类型的符号引用
    (1) 数据结构
    CONSTANT_NameAndType_info {
    	u1 tag;
    	u2 name_index;
    	u2 descriptor_index;
	}
	(2) 约束项
    	> name_index：必须是CONSTANT_Utf8_info结构的常量，表示字段与字段类型或方法与方法类型的名称。
        > 构造方法名称统一使用<init>。
        > descriptor_index：必须是CONSTANT_Utf8_info结构的常量，表示一个有效的字段描述符或方法描述符。
```

```
11 CONSTANT_Utf8_info	utf8编码字符串
	(1) 数据结构
	CONSTANT_Utf8_info {
		u1 tag;
		u2 length;
		u1 bytes[length];
	}
	(2) 约束
		length：该值指明了bytes[]数组的长度
```

```
12 CONSTANT_MethodHandle_info	动态类型语言支持
	(1) 数据结构
	CONSTANT_MethodHandle_info {
		u1 tag;
		u1 reference_kind;
		u2 reference_index;
	}
	(2) 解释
		表示方法句柄，这是虚拟机为实现动态调用invokeddynamic指令锁增加的常量结构。
	(3) 项约束
		reference_kind：取值范围为1~9，包括1和9，表示方法句柄的类型；
		reference_index：其值为指向常量池中的某个常量的索引
	
```

```
13 CONSTANT_MethodType_info
	(1) 数据结构
	CONSTANT_MethodType_info {
		u1 tag;
		u2 descriptor_index;
	}
	(2) 解释
		表示方法类型，与CONSTANT_MethodType_info结构一样，也是虚拟机为实现动态调用invokeddynamic指令锁增加的常量结构。
	(3) 项约束
		descriptor_index：必须是CONSTANT_Utf8_info结构的常量，指向常量池中的某一CONSTANT_Utf8_info结构的常量。
```

```
14 CONSTANT_InvokeDynamic_info
	(1) 数据结构
	CONSTANT_InvokeDynamic_info {
		u1 tag;
		u2 bootstrap_method_attr_index;
		u2 name_and_type_index;
	}
	(2) 解释
		表示一个动态方法调用点，即invokeddynamic指令用到的引导方法bootstrap method以及引导方法所用到的动态调用名称、参数、返回类型。
	(3) 项约束
		bootstrap_method_attr_index：指向class文件结构属性表中引导方法表的某个引导方法；
		name_and_type_index：指向的常量必须是一个CONSTANT_NameAndType_info常量。
```

## JVM内存结构

​	大体上来说，由class文件、类加载器子系统（包含知识点：类的加载过程和类的加载方法）、运行时数据区（包含知识点：程序计数器、堆、栈、方法区）、执行引擎、本地方法接口和本地方法库组成。

### JVM内存结构简图

![](pics\JVM内存结构简图.png)

### JVM内存结构详图

![JVM内存结构详图](pics\JVM内存结构详图.png)

### 类加载器子系统

​	》类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识，叫做魔数（magic）CA FE BA BE。

​	》ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。

​	》加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。

#### 类的加载过程（大厂考察点，百度+1）

![](pics\类的加载过程.png)

> 加载 Loading

1. 通过一个类的全限定名称获取定义此类的**二进制字节流**；
2. **将这个字节流**所代表的**静态存储结构**转化为方法区的**运行时数据结构**；
3. 在**内存中生成**一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的**访问入口**。

> 链接 Linking

 1.  验证 Verify

     目的：确保Class文件的字节流中包含的信息符合当前虚拟机要求，**保证被加载类的正确性**，不会危害虚拟机自身安全；

     验证的内容：class文件的文件格式、class文件的元数据、class文件的字节码以及class文件的符号引用。

 2.  准备 Preparation

     目的：**为类变量（private修饰的变量，即类中的私有属性）分配内存并且设置该类变量的默认初始值，即0值**。

     注意：这里不包含用final修饰的static，因为final在编译时就会分配了，**准备阶段做的是显式初始化**。

     ​			这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

 3.  解析 Resolution

     目的：**将常量池内的符号引用转换成直接引用的过程**。

     解释：事实上，解析操作往往会伴随着JVM在**执行完初始化之后在执行**。

     解析的对象：主要针对类或接口（Class_info）、字段（Fieldref_info）、类方法（Methodref_info）、接口方法（InterfaceMethodref_info）、名称和类型（Name_And_Type_info）等。

> 初始化 Initialization

​	目的：执行类构造器方法<clinit>()的过程。

​	解释：**此方法不需要定义**，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来的。

​				构造器方法中指令**按语句在源文件中出现的顺序执行**。

​	<clinit>()不同于类的构造器（<init>()）。该构造器是虚拟机视角下的<init>()。

​	**若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕。**

​	虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。

#### 类的加载方法（虚拟机自带的类加载器而言）

即类的加载器分类

> 启动类加载器 又名 引导类加载器，Bootstrap ClassLoader

​	》这个类加载器使用C/C++语言实现的，嵌套在JVM内部。

​	》它用来加载Java的核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。

​	》不会继承自java.lang.ClassLoader，没有父加载器。

​	》加载扩展类和应用程序类加载器，并指定为它们的父类加载器。

​	》出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类。

> 扩展类加载器 Extension ClassLoader

​	》Java语言编写的，由sun.misc.Launcher$ExtClassLoader实现。

​	》**派生于ClassLoader类。**

​	》父加载器为启动类加载器。

​	》从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。**如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。**

> 应用类加载器 又名 系统类加载器，APPClassLoader

​	》java语言编写的，由sun.misc.Launcher$AppClassLoader实现的。

​	》派生于ClassLoader类。

​	》父类加载器为扩展类加载器（Extension ClassLoader）。

​	》它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库。

​	》**该类加载器是程序中默认的类加载器**，一般来说，Java应用的类都是由它来完成加载的。

​	》通过CLassLoader#getSystemClassLoader()方法可以获取该类加载器。

> 用户自定义类加载器

​	基本上上面3种类加载器相互配合执行，已经够日常应用程序的开发使用了，必要时，程序员还可以自定义类加载器，来制定类的加载方式。

​	为什么要Java能够定义类加载器？

​	》隔离加载类；

​	》修改类加载的方式；

​	》扩展加载源；

​	》防止源码泄露。

​	实现步骤：

​	》可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特定的需求。

​	》JDK1.2之前，需要继承ClassLoader类并重写loadClass()方法实现自定义类加载器；JDK1.2之后，建议把自定义的类加载逻辑写在findClass()方法中，而不是采用重写loadClass()方法。

​	》在编写自定义类加载器时，如果没有过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免字节去编写findClass()方法以及其获取字节码流的方式，使自定义类加载器编写更加简洁。

#### ClassLoader类

​	它是一个抽象类，其后面所有的类加载器都继承自ClassLoader（当然，不包含启动类加载器）。 

​	获取ClassLoader的途径

​	》获取当前类的ClassLoader

​		class.getClassLoader()

​	》获取当前线程上下文的ClassLoader

​		Thread.currentThread().getContextClassLoader()

​	》获取系统的ClassLoader

​		ClassLoader.getSystemClassLoader()

​	》获取调用者的ClassLoader

​		DriverMannger.getCallerClassLoader()

#### 双亲委派机制

​	Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存中从而生成class对象。而且**加载某个类的class文件时，Java虚拟机采用的是双亲委派机制**，即把请求交给父类处理，它是一种任务委派模式。

##### 双亲委派机制工作原理

<img src="pics\双亲委派机制工作原理.png" alt="双亲委派机制工作原理" style="zoom: 80%;" />

##### 双亲委派机制举例

<img src="pics\双亲委派机制.jpg" style="zoom: 67%;" />

##### 双亲委派机制的优势

​	》避免类的重复加载；

​	》保护程序安全，防止核心API被随意篡改

​		× 自定义类：java.lang.String

​		× 自定义类：java.lang.随意取名

#### 沙箱安全机制

​	举例说明：自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载JDK自带的文件(rt.jar包中的java\String.class)，报错信息会说没有main()方法，就是因为加载的是rt.jar包中的String 类。这样可以保证对java核心源代码的保护，这就是所说的沙箱安全机制。

#### 类的主动使用和被动使用

主动使用，分为7种情况：

​	》创建类的实例；

​	》访问某个类或接口的静态变量，或者对静态变量赋值；

​	》调用类的静态方法；

​	》反射（比如：Class.forName("类的全限定名")）；

​	》初始化一个类的子类；

​	》Java虚拟机启动时被标明为启动类的类；

​	》JDK 7 开始提供的动态语言支持：

​		java.lang.invoke.MethodHandle实例的解析结果，

​		REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

​	除了以上7种情况，其他使用Java类的方式都被看做是对类的**被动使用**，都**不会导致类的初始化**。

### 运行时数据区 Runtime Data Area

![](pics\Runtime Data Area.png)

​	Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区会随着线程开始和结束而创建和销毁。

​	》每个线程：独立包括程序计数器、栈、本地栈；

​	》线程间共享：堆、堆外内存（永久代或元空间、代码缓存等）

#### JVM系统线程

1.线程是什么：线程是一个程序里的运行单元。JVM允许一个应用由多个线程并行的执行；

2.线程在JVM中充当的角色：在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。

​	》当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。

3.线程在JVM中如何使用：操作系统负责所有线程的安排调度任何一个可用的CPU上。一旦本地线程初始化成功，他就会调用Java线程中的run()方法。

4.如何查看所用的线程有哪些：使用jconsole或者其他的调试工具，就可以看见后台有哪些线程在运行。这些后台线程不包括调用main()方法所创建的线程以及所有mian 线程自己创建的线程。

​	》后台系统线程在HotSpot JVM里主要是以下几个：

​		（1）虚拟机线程。需要JVM达到安全点才会出现。

​		（2）周期任务线程。比如：中断操作。一般用于周期性操作的调度执行。

​		（3）GC线程。为不同中类的垃圾回收幸会提供支持。

​		（4）编译线程。在运行时会将字节码编译成本地字节码。

​		（5）信号调度线程。接收信号并发送给JVM。



#### JVM的程序计数器 Program Counter Register

1.用来干什么？

​	计算机操作系统中的解答：用来存储命令相关的现场信息。

​	JVM中的作用：PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。

2.简介

​	》它是一块很小的内存空间，也是运行速度最快的存储区域。

​	》在JVM规范中，每个线程都有他自己的程序计数器，是线程私有的，生命周期与线程的生命周期是一样的。同存亡

​	》用来保证任何一个线程中都只有一个方法在执行。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是在执行native方法，则是未指定值(undefined)。

​	》它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等都需要依赖程序计数器来完成。

​	》字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令。

​	》不存在OutOfMemoryError

3.面试考题

》考题1：使用PC寄存器存储字节码指令地址有什么用？或者说，为什么使用PC寄存器记录当前线程的执行地址？

​	答：因为CPU需要不停的切换各个线程，等到切换回来以后，就需要知道是从哪开始继续执行。

​		   JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

》考题2：PC寄存器为什么会被设定为线程私有？

​	答：所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复，如何保证不出差错呢？**为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法就是为每个线程都分配一个各自的PC寄存器，这样的话，各个线程之间便可以进行独立的计算，从而不会出现相互干扰的情况。**

​			由于CPU时间片轮换限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。如何保证经常性的中断或恢复对线程之间的程序执行不出差错呢？每个线程在创建以后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。

4.CPU时间片

​	即CPU分配给各个程序的时间，每个线程被分配一个时间段，称为它的时间片。

​	宏观上来说，同时打开的多个应用程序之间是并行的，互不影响；微观上来说，由于只有一个CPU，一次只能处理程序要求的一部分。为了达到公平，一种方法就是引入时间片的概念，每个程序轮流执行。

#### 虚拟机栈和堆

#### 栈和堆的区别

​	》栈是运行时单位，而堆是存储的单位。

​	》栈解决的问题是运行问题，即程序如何运行，或者说程序如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。

#### Java虚拟机栈

1.是什么：每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧，对应着一次次的Java方法调用。是线程私有的。

2.生命周期：和线程共存亡（因为栈是线程私有的）。

3.有什么用：主管Java程序的运行，还保存方法的局部变量、部分结果，并参与方法的调用和返回。

4.有什么特点：栈是一种快速有效的分配（临时存储）存储的方式，访问速度仅次于程序计数器。

5.JVM直接对Java栈的操作只有两个：

​	》每个方法执行，伴随着进栈；

​	》执行结束后，出栈。

6.**对于栈来说，不存在垃圾回收（GC）和内存溢出问题（OOM），但存在栈溢出StackOfoverflowError。**

#### 面试题：开发中遇到的异常有哪些？

​	JVM中，允许Java栈的大小是动态的或者是固定不变的。涉及的异常如下：

​		》内存溢出OOM（OutOfMemoryError），针对栈可动态扩容的情况。**Java虚拟机栈可以是动态扩展的**，如果在尝试扩展时无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，将会抛出该异常。

​		》栈溢出StackOverflowError，针对栈本身内存大小不变的情况。如何出现：**如果采用的是固定大小的虚拟机栈**，线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出该异常。

#### Java虚拟机栈续

**1.设置栈内存大小**

​	使用参数-Xss（中间的s代表stack）选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

**2.栈中存储什么**

​	方法栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

##### **3.栈的运行原理**

（1）不同线程中所包含的栈帧是不允许存在相互引用，即**不可能在一个栈帧之中引用另外一个线程的栈帧。**
（2）执行引擎运行的所有字节码**指令只针对当前栈帧进行操作**。
（3）如果在**该方法中调用了其他方法**，对应的新的栈帧会被创建出来，**放在栈的顶端，成为新的当前帧**。
（4）如果当前方法调用了其他方法，方法返回之际，**当前栈帧会传回此方法的执行结果给前一个栈帧**，接着，**虚拟机丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。（栈的栈帧弹出，新的栈帧顶替旧的栈帧）**

（5）Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。

##### **4.栈帧的内部结构**

​	》局部变量表；

​	》操作数栈；

​	》动态链接（指向运行时常量池的方法引用）

​	》方法返回地址

​	》一些附加信息

**4.1 局部变量表**

​	也称为局部变量数组或本地变量表。由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。

》作用：主要用来存储方法参数和定义在方法体内的局部变量。包括：基本数据类型、引用数据类型（reference）以及方法返回地址（returnAddress）类型。

》局部变量表，最基本的存储单元是Slot (变量槽)。

**4.2 操作数栈**

》作用1：在方法执行过程中，**根据字节码指令，往栈中写入数据或提取数据**，即入栈(`push`)/出栈(`pop`)。

》作用2：主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

》**操作数栈就是JVM执行引擎的一个工作区**，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。

》操作数栈数据访问的方式：**只能通过标准的`入栈(push)`和`出栈(pop)` 操作来完成一次数据访问**。

》**栈顶缓存技术：解决频繁执行内存的读写操作所带来的执行速度问题**。

​	由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存(ToS， Top-of-Stack Cashing)技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。**

###### **4.3 动态链接**

》作用：指向运行时常量池的方法引用。每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。引用的目的是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如: invokedynamic指令

》方法的调用：解析和分派

（1）静态链接与动态链接

​	静态链接：当一个字节码文件被装载进JVM内部时，如果**被调用的目标方法在编译期可知，且运行期保持不变时**。这种情况下**将调用方法的符号引用转换为直接引用的过程称之为静态链接。**

​	动态链接：如果**被调用的方法在编译期无法被确定下来**，也就是说，**只能够在程序运行期将调用方法的符号引用转换为直接引用**，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。



（2）早期绑定和晚期绑定  **绑定**是一个字段、方法或者类在**符号引用被替换为直接引用的过程**，这仅仅发生一次。

​	**早期绑定是对于静态链接而言的**：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时,即可将这个方法与所属的类型进行绑定。

​	**晚期绑定是对于动态链接而言的**：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚	期绑定。

（3）虚方法与非虚方法

​	**非虚方法是对于静态链接而言的**：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。

​	同理，**虚方法是对于动态链接而言的**。

静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。其他都是虚方法。

（4）方法调用指令

​	普通调用指令：

​	> invokestatic：调用静态方法，解析阶段确定唯一方法版本；

​	> invokespecial： 调用<init>方法、私有及父类方法，解析阶段确定唯- -方法版本；

​	> invokevirtual：调用所有虚方法；

​	> invokeinterface： 调用接口方法。

​	动态调用指令：invokedynamic，动态解析出需要调用的方法，然后执行。

​	**前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。**其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。

（5）动态调用指令invokedynamic的使用

​	为了实现“动态类型语言”支持而做的一种改进。

​	> 动态类型语言和静态类型语言

​		**静态类型语言**：对语言的类型检查在**编译期进行**；

​		**动态类型语言**：对语言的类型检查在**运行期进行**。

​	说的再直白一点就是，静态类型语言是判断变量自身的类型信息;动态类型语言是判断变量值的类型信息，**变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征**。

**（6）方法重写的本质**

​	a) 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。

​	b) 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。
​	c) 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
​	d) 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

> IllegalAccessError：程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。

**（7） 虚方法表**

​	在面向对象的编程中，会很**频繁的使用到动态分派**，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能**影响到执行效率**。因此，**为了提高性能**，JVM采用在**方法区建立一个虚方法表**(virtual method table) (非虚方法不会出现在表中)来实现。使用**索引表来代替查找**。

**4.4 方法返回地址（returnAddress）**

》作用：存放该方法的PC寄存器的值。

》一个方法的结束有两种方式：

​	> 正常执行完成；

​	> 出现未处理的异常，非正式退出执行。

​	**无论哪种方式结束，在方法退出后都返回到该方法被调用的位置。**方法**正常退出**时，调用者的**pc计数器的值作为返回地址**，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中–般不会保存这部分信息。

4.5 一些附加信息

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：**对程序调试提供支持的信息**。

## 栈的相关面试题
1、举例栈溢出的情况?
	》StackOverflowError。当栈的内存大小保持不变时，新的栈帧想要入栈而栈没有足够的内存取给它分配栈空间，就会出现栈溢出的情况。
2、调整栈大小，就能保证不出现溢出吗?
	不能，调整栈的大小可以让程序出现 StackOverflowError 更晚一些
3、分配的栈内存越大越好吗?
	不，栈内存越大，可以让程序出现 StackOverflowError 更晚一些，但是不能保证程序不出现 StackOverflowError，栈内存空间变大，总的内存不变，其他空间会变小
4、垃圾回收是否会涉及到虚拟机栈?
	不会的，虚拟机栈只有进栈出栈，出栈即丢弃。所以不会出现GC
5、方法中定义的局部变量是否线程安全?
	不一定，具体问题具体分析。如果只有一个线程才可以操作该数据，则是线程安全的；如果有多个线程操作此数据，则此数据是共享的，如果不考虑同步机制的话，就会存在线程安全的问题。

#### 本地方法栈（Native Method Stack）

**本地方法篇**

》什么是本地方法：就是**Java程序调用非Java代码的接口**。一个`Native Method`是这样一个Java方法: 该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用`extern` "C" 告知C++编译器去调用一个C的函数。

》本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。

》**本地方法是使用C语言实现的。**

》为什么要使用本地方法？

（1）**与Java环境外交互**：本地方法为我们提供了一个非常**简洁的接口**，而且我们无需去了解Java应用之外的繁琐的细节。

（2）**与操作系统交互**：JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器(解释字节码)和一些连接到本地代码的库组成。通过使用本地方法，我们得以用Java实现了jre的**与底层系统的交互**，甚至JVM的一些部分就是用c写的。还有，如果我们要**使用一些Java语言本身没有提供封装的操作系统的特性时**，我们也需要使用本地方法。

（3）Sun’ s Java：Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。

**本地方法栈篇**

》作用：Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。

》属于虚拟机栈的一种，所以也是线程私有的。

》允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面，与Java虚拟机栈是相同的)

》使用方法：Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。

》如何调用？

​	当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。

​	➢本地方法可以通过本地方法接口来**访问虚拟机内部的运行时数据区**。
​	➢它甚至可以**直接使用本地处理器中的寄存器**。
​	➢直接从**本地内存的堆中分配任意数量的内存**。

**并不是所有的JVM都支持本地方法**。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。

**在Hotspot JVM中， 直接将本地方法栈和虚拟机栈合二为一 。**

#### 堆

##### 堆的属性

》一个JVM实例**只存在一个堆内存**，堆是Java内存管理的核心区域。

》Java堆区在**JVM启动的时候即被创建**，空间大小也就被确定了（但是，堆内存的大小是可以调节的）。是JVM管理的**最大一块内存空间**。

》堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的。

》**所有的线程共享Java堆**（需要注意的是：堆中不是所有的内存资源都是共享的，TLAB就是需要分配内存的每个线程私有的。），在堆中，有一部分被划分为**线程私有的缓冲区**（ThreadLocal Allocation Buffer， **TLAB**）。

》“几乎”所有的**对象实例以及数组**都应当在运行时分配在堆上。

》栈中保存的引用就指向对象或者数组在堆中的位置。

》在**方法结束后，堆中的对象不会马上被清除**，而是等到**垃圾回收的时候才会被移除**。

》**堆**是GC（Garbage Collection，垃圾回收器）执行**垃圾回收的重点区域**。

设置堆的大小：-Xms和-Xmx。比如：Xms10m：堆的初始空间就是10M；Xmx10m：设置堆的最大空间为10M。

- 通常会将`-Xms`和`-Xmx`两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
- 默认情况下，初始内存大小：物理电脑内存大小 `/ 64`；最大内存大小：物理电脑内存大小 `/ 4`
- 一旦堆区中的内存大小超过`-Xmx`所指定的最大内存时，将会抛出`OutOfMemoryError`异常。

##### **理清重点知识**

- 一个进程对应一个JVM实例，一个JVM实例对应一个运行时数据区，一个运行时数据区对应一个方法区和堆；
- 一个进程里有多个线程，多个线程共享进程里的堆和方法区；
- 一个进程里的多个线程，每个线程都有各自的虚拟机栈、本地方法栈和程序计数器。

##### 堆内存空间详细划分

现代垃圾回收器大部分都基于分带收集理论设计的。

Java 7 之前，堆内存逻辑上分成三部分：新生区(Young Generation Space) + 养老区(Tenure generation Space) + 永久区(Permanent Space)。

​	新生区又被划分为Eden（伊甸）区和Survivor（存活）区。

Java 8以及之后，堆内存逻辑上被分为：新生区 + 养老区 + 元空间(Meta Space)。

**jdk1.7 堆中的结构**

![](pics\jdk1.7 堆中的结构.png)

**jdk 1.8 堆中的结构**

![](pics\jdk 1.8 堆中的结构.png)

##### 新生代和老年代

》存储在JVM中的Java对象可以被分成两类：

- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。
- 另一类对象的生命周期却非常长，在某些极端的情况下还能与JVM的生命周期保持一致。

》Java堆区进一步细分的话，可以划分为新生代(YoungGen)和老年代(OldGen)

​	其中新生代又可以划分为Eden空间、Survivor0空间和Survivor1空间 (有时也叫做from区、to区)。

》配置新生代与老年代在堆结构的占比。

- 默认`-XX:NewRatio=2`，表示新生代占1，老年代占2，新生代占整个堆的`1/3`
- 修改`-XX:NewRatio=4`，表示新生代占1，老年代占4，新生代占整个堆的`1/5`

**知识点梳理**
》在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1。

》当然开发人员**可以**通过选项-XX:SurvivorRatio**调整这个空间比例**。比如-XX:SurvivorRatio=8

》**几乎所有**的Java对象都是**在Eden区被new出来的**。**绝大部分**的Java对象的**销毁都在新生代**进行了。
	➢IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。

​		可以使用选项-Xmn设置新生代最大内存大小
​	➢这个参数一般使用默认值就可以了。

​		-XX:-UseAdaptiveSizePolicy 关闭内存自适应的内存分配策略

​		-XX:+UseAdaptiveSizePolicy 开启内存自适应的内存分配策略

##### 图解对象的分配过程

![](pics\图解对象分配的过程.png)

流程图

![](pics\图解对象分配的流程图.png)

###### 复制算法详解 掌握

​	**伊甸园满了,就会触发gc(minor gc)，而gc就会把标识为垃圾的对象干掉，不是垃圾的对象就要转移到幸存区，把伊甸园让出来给新的对象用。**

​	关于垃圾回收：频繁在新生区收集，很少早养老区收集，几乎不在永久区/元空间收集。

MinorGC（年轻代GC）的过程（复制 -> 清空 -> 互换）

1.Eden、SurvivorFrom复制到SurvivorTo，年龄age + 1

​	首先，当Eden区满的时候，会触发第一次MinorGC，把还存活的对象拷贝到SurvivorFrom区，当Eden区再次触发MinorGC的时候，会扫描Eden区和From区，对这两个区域进行垃圾回收，经过这次回收后，还存活的对象，则直接复制到To区（如果From区有对象年龄已经达到了老年区的标准阈值（age=15），则复制到老年区），同时，把这些对象的年龄 + 1。

2.清空 Eden、SurvivorFrom

​	然后，清空Eden和SurvivorFrom中的对象，即**复制之后有交换，谁空谁就是To区（对于S0和S1区）**。

3.SurvivorTo和SurvivorFrom互换

​	最后，.SurvivorTo和SurvivorFrom互换，原来的.SurvivorTo称为下一次MinorGC时的SurvivorFrom区。不分对象会在From区和To区来回复制，如此交换15次（由-XX:MaxTenuringThreshold=<N>决定，默认值是15），最终如果还是存活，就进入老年代。

###### MinorGC | MajorGC | Full GC

> MinorGC(Young GC)发生在新生代（新生区）

​	》只针对新生代区域的GC，指发生在新生代的垃圾回收动作，因为大多数Java对象存活率都不高，所以MinorGC使用非常频繁，一般回收速度也比较快。

​	》当Eden满，会触发MinorGC，Survivor满不会触发该GC。

​	》MinorGC会引发STW（Stop the World -->**暂停其他用户线程，等垃圾回收结束，用户线程才能恢复**）。

> MajorGC 发生在老年代（养老区）

​	》major GC 是**回收老年代的垃圾**；

​	》major gc 的速度一般比Minor gc 慢10倍以上，STW时间更长。

> full GC 整堆回收

​	》触发情况：(1) 调用System.gc()时，系统建议执行Full GC，但不是必然执行的。		

​						  (2) 老年代空间不足

​						  (3) 方法区空间不足

​	》full GC 就会出现所谓的STW(stop the world)现象,即所有的进程都挂起等待清理垃圾

​	》full GC是**回收整个Java堆和方法区的垃圾收集。**
​	》full gc 是开发调优中尽量避免的，这样暂时时间会短一些

> Mixed GC混合收集

​	》收集整个新生代以及部分老年代的垃圾。目前只有G1 GC有这种行为。

##### 堆空间分代思想

为什么要进行分代？不分代就不行吗？

​	可以不分代，分代只是为了**优化GC的性能**。如果不分代，在执行垃圾回收的时候，就需要在整个的堆空间中去找需要回收的对象（age=0的对象才回收），这样做会耗费大量的时间。然而分代后，新生代的Eden区是创建对象的主要存放区，Survivor区和老年代主要存储Eden中未被垃圾回收的对象，从而在进行堆空间垃圾回收的大部分情况都是在Eden区，从而减小了回收时间，提高回收效率。

> 针对不同年龄阶段的对象分配原则

​	》优先分配到Eden

​	》大对象直接分配到老年代

​	》长期存活的对象分配到老年代

​	》动态年龄的判断

​	(如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半,年龄大于或等于该年龄对象可以直接进入老年代,无须等到MaxTenurningThreshold中要求的年龄)

​	》空间分配担保

​	(JDK6之后,只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC,否则将进行Full GC)

##### TLAB（Thread Local Allocation Buffer，线程私有缓冲区）

**为什么会有TLAB？**

​	**因为堆空间是对所有线程共享的资源，当有多个线程都在堆空间中分配内存，就容易出现线程安全的问题。所以就有了TLAB的出现。在堆空间分配内存的时候，首先为每个线程分配一个TLAB线程私有分配缓存区，当有对象创建需要分配内存时，首先是在线程各自的TLAB中进行内存分配的，如果内存不够，分配失败，JVM才会选择使用加锁机制来确保数据的原子性（线程之间内存分配互不干扰），从而在Eden中为该线程新创建的对象分配内存。**

①. 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，**JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内**

②. 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选**

③. 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然可通过选项"-XX:TLABWasteTargePercent"设置TLAB空间所占用Eden空间的百分比大小

④. **一旦对象在TLAB空间分配内存失败时**，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，**从而直接在Eden空间中分配内存**

![](pics\TLAB.png)

##### 堆空间的参数设置

​	-XX:+PrintFlagsInitial	查看所有的参数的默认初始值

​	-XX:+PrintFlagsFinal	查看所有的参数的最终值（可能会存在修改，不再是最终值）

​	-Xms	初始堆空间内存（默认为物理内存的1/64）

​	-Xmx	设置最大堆内存空间（默认为物理内存的1/4）

​	-Xmn	设置新生代的大小（初始值以及最大值）

​	-XX:NewRatio	配置新生代与老年代在堆结构的占比

​	-XX:SurvivorRatio	设置新生代中Eden的S0和S1的空间比例

​	-XX:MaxTenuringThreshold	设置新生代中对象的最大年龄

​	-XX:+PrintGCDetails	输出详细的GC处理日志

​	打印GC简要信息：-XX:+PrintGC		/ 	-verbose:gc

​	-XX:HandlePromotionFailure		是否设置空间分配担保	

##### 内存分配策略

​	（或者说成是对象提升的规则）

​	在发生Minor GC之前，虚拟机会检查老年代最大可用空间的连续空间是否大于新生代所有对象的总空间：

- 如果大于，则此次Minor GC是安全的；
- 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否是允许担保失败：
  - 如果==HandlePromotionFailure=true==，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
    - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
    - 如果小于，则改为进行一次Full GC。
  - 如果==HandlePromotionFailure=false==，则改为进行一次Full GC。

​    从JDK 7开始，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，从Open JDK源码中就可以看出。虽然还定义了HandlePromotionFailure参数，但是在代码中已经不会使用了。并且规则变成了：**==只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小==就会进行Minor GC，否则将进行Full GC**。

##### 堆是分配对象存储的唯一选择吗？

​	随着**JIT编译器的发展与逃逸分析技术**的成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有得我对象都分配在堆上也逐渐变得不那么绝对了。

​	但是，总的来说，所有的对象实例都存储在堆上的。因为逃逸分析技术不够完善，还是有很多不足的地方。比如：方法中的所有对象都发生了逃逸的情况，逃逸分析的过程就做了无用功，消耗了时间不做事。

​	特殊情况1：==如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配==。这样就无需在堆上分配内存，以及无需进行垃圾回收了，从而优化程序的性能。**这是最常见的堆外存储技术**。

​	特殊情况2：（**面阿里可用**）基于Open JDK深度定制的**TaoBaoVM**，其中创新的==GCIH（GC Invisible Heap）技术实现了off-heap，将生命周期较长的Java对象从堆heap中移至heap外，并且规定GC不能管理GCIH内部放入Java对象==，**以此达到降低GC的回收频率和提升GC的回收效率。**

##### 逃逸分析技术

​	使用逃逸分析技术，可以**将本该在堆上分配内存的对象使用栈来分配内存**。

​	使用-XX:+DoEscapeAnalysis开启逃逸分析（默认是开启的，或者使用-XX:-DoEscapeAnalysis关闭）。

逃逸分析的基本行为就是==分析对象动态作用域==：

- 当一个对象在方法中被定义后，对象只在**方法内部使用**(==这里关注的是这个new对象的实体==)，则认为**没有发生逃逸**。

- 当一个对象在方法中被定义后，它**被外部方法所引用**,则认为**发生逃逸**。例如作为**调用**参数传递到其他地方中。

  ====例子很重要====

``` java
//(1). 没有发生逃逸的对象,则可以分配到栈上,随着方法执行的结束,栈空间就被移除
// 该方法没有返回值，内部的对象v没有不会被外部方法所调用，所以不会发生逃逸。
public void my_method() {
    V v = new V();
    // use v
    // ....
    v = null;
}
//(2). 下面代码中的 StringBuffer sb 发生了逃逸
// 由于方法的返回值类型是StringBuffer，方法内部创建的sb对象就可能被外部调用，从而发生逃逸现象。所以这里的sb对象只能分配在堆空间上
public static StringBuffer createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
}
//(3) 如果想要StringBuffer sb不发生逃逸,可以这样写
// 为什么这里就不会逃逸？因为返回值变成了String而不是StringBuffer，那么创建的StringBuffer对象就不会被其他方法所调用，只在本类中使用，所以此时变成了和(1)种是一样的情况，该对象不会发生逃逸。
public static String createStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}

// (4) 方法中没有返回值，但调用了其他方法来对该方法的属性赋值，则也有可能发生逃逸
```

##### 为什么说能使用局部变量的，就不要使用在方法外定义？

​	这就涉及到逃逸分析技术的使用了。使用逃逸分析技术的好处：**能够在栈上分配内存的就不要在堆上分配内存了**。因为在栈上为变量分配内存就**不用垃圾回收器回收**，栈是随着方法运行结束就销毁，**提高程序的执行效率**。逃逸分析技术关注的是对象的作用域：在一个方法内声明一个变量（或者对象）后，如果该变量（或者该对象）只在方法内部使用，则不会发生逃逸，不逃逸的变量（或对象）直接在栈上分配内存而不是堆上。

##### 逃逸分析之代码优化

使用逃逸分析，编译器可以对代码做如下优化：

- 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配。**使用-XX:+DoEscapeAnalysis开启逃逸分析**
- 同步省略（或者叫做锁消除）。如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
- 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在堆空间，而是存储在栈空间中



#### 方法区

##### 方法区概述

- 方法区在JVM启动的时候就被创建，情切它的物理内存空间和Java对空间一样，都可以是不连续的（逻辑上连续即可），关闭JVM就会释放方法区内存；
- 方法区在逻辑上来说是堆的一部分，但是在不同虚拟机的实现是不一样的。**方法区是一种规范，而永久代和元空间是方法区的一种实现形式。**
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误OOM。
  - 加载大量的第三方jar包；
  - Tomcat部署的工程过多（30-50）；
  - 大量动态的生成反射类。

- 对于HotSpot JVM而言，方法区还有一个别名：非堆（Non-heap），目的就是要和堆分开，方法区可以看成一块独立于Java堆的内存空间。



##### 方法区的内部结构

​	用于存储已被虚拟机加载的 ==类型信息、常量、静态变量、即时编译器编译后的代码缓存==等

![](pics\方法区存储内容图示.png)

- 类型信息。对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
  - 完整有效的名称；
  - 直接父类的完整有效名称；
  - 修饰符；
  - 直接接口的一个有序列表。

- **域信息，即成员变量**
  - JVM必须在方法区中保存类型的所有域相关的信息以及域的声明顺序；
  - 与相关的信息包括：域名称、域类型、域的修饰符；

- 方法信息。JVM必须保存所有方法的以下信息：
  - 方法名称；
  - 方法返回类型；
  - 方法参数的数量和类型（按顺序）；
  - 方法的修饰符；
  - 方法的字节码、操作数栈、局部变量表以及表的大小；
  - 异常表（abstract和native除外）。包括：每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。

- **non-final的类变量**
  - 被声明为**static final的常量number在编译的时候就被赋值了**，这不同于**没有被final修饰的static变量count是在类加载的准备阶段被赋值为默认的初始化值,在初始化的时候赋予正确的初始化值。**

##### 方法区的演进细节
①. Jdk 1.6 及之前：有永久代，静态变量、字符串常量池在方法区

②. Jdk 1.7 ：有永久代，但已经逐步 " 去永久代 "，字符串常量池、静态变量保存在堆中

③. jdk 1.8 及之后： 无永久代，常量池在元空间。但静态变量、字符串常量池仍在堆中

##### ==为什么要用元空间取代永久代==

- 为永久代设置空间大小是很难确定的
  - 永久代参数设置过小，在某些场景下，如果动态加载的类过多，容易产生永久区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误；
  - 永久代参数设置过大，导致空间浪费；
  -  而默认情况下，元空间的大小受本地内存限制，就可以在一定程度上避免永久代的情况。

- 对永久代进行调优是很困难的
  - 方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型，而不再使用的类或类的加载器回收比较复杂，Full GC回收的时间长。

##### String table 字符串常量表为什么要从永久代调整到堆空间中

​	因为永久代的回收效率很低，只有在触发Full GC的时候才会进行一次回收。而我们在开发中，会有大量的字符串被创建，如果回收效率低，就容易导致永久代内存空间不足，而选择放到堆里，就可以及时回收string字符串创建而产生的内存。

##### 常量池的理解

- 常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型、字面量等信息。
- 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Poo1 Table），**==包括各种字面量和对类型域和方法的符号引用==**。
  - 字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。
  - 符号引用则属于编译原理方面的概念，包括下面三类常量：
    （1）类和接口的全限定名
    （2）字段的名称和描述符
    （3）方法的名称和描述符
- Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，所以换另一种方式，可以存到常量池，在这个字节码中，包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。

##### 何为运行时常量池

-  常量池是 *.class 文件，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的**符号地址变为真实地址**；
- 运行时常量池（ Runtime Constant Pool）是方法区的一部分。
- **常量池表**（Constant Pool Table）是Class文件的一部分，**用于存放编译期生成的各种字面量与符号引用**，这部分内容将**在类加载后存放到方法区的运行时常量池中**。
- 运行时常量池中包含多种不同的常量，包括：编译期就已经明确的数值字面量、运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。

##### 方法区的垃圾回收

》主要回收两部分内容：**常量池中废弃的常量和不再使用的类型**。

》HotSpot虚拟机对常量池的回收策略是很明确的，**只要常量池中的常量没有被任何地方引用，就可以被回收**。回收废弃常量与回收Java堆中的对象非常类似。

》判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

​	（1）该类所有的实例都已经被回收，也就是**Java堆中不存在该类及其任何派生子类的实例**。

​	（2）**加载该类的类加载器已经被回收**，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI、JSP的重加载等，否则通常是**很难达成的**。

​	（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

》Java虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了 -Xnoclassgc 参数进行控制，还可以使用 -verbose：class以及-XX: +TraceClassLoading、-XX:+TraceClassUnLoading查 看类加载和卸载信息

》在大量使用反射、动态代理、CGLIB等字节码框架，动态生成JSP以及OSGI这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

---

# 看完GC，回头看7 8 9

---

## 垃圾回收算法

什么是垃圾？垃圾不清理有什么坏处？

​	垃圾是指在运行程序中没有任何指针指向的对象，这个对象就需要被回收。

​	如果不及时清除这些垃圾，那么垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。



### 哪些是需要回收的垃圾？怎么回收这些垃圾？

​	从提问的方式可以将垃圾回收的方式分为两种：

- 标记阶段：即标记出哪些是垃圾。
  - 引用计数算法
  - 可达性分析算法
- 清除阶段：清除被标记的垃圾。
  - 标记-清除算法
  - 复制算法
  - 标记-压缩算法

除了以上提到的算法，还有常见的：分代收集算法、增量收集算法以及分区算法。。。

![](pics\GC回收的方法.png)

### 垃圾标记阶段

​	对象存活判断的方式：==引用计数算法和可达性分析算法==。

### 标记阶段之引用计数算法

​	==原理== ：假设有一个对象A，任何一个对象对A的引用，那么对象A的引用计数器+1，当引用失败时，对象A的引用计数器就-1，如果对象A的计数器的值为0，就说明对象A没有引用了，可以被回收。

缺陷：**无法解决循环引用的问题**，导致GC永远都清除不了。因此，JVM中没有使用该回收算法。

==循环引用是什么？== 

​	如果一个主方法调用了多个方法，方法与方法之间也有互相调用，当这个主方法标记计数器达到0值时，被回收了，但它引用的方法还没有被回收，这样引用的方法与方法之间就形成了一个环路，这个环路就是循环引用，不会被回收掉，从而导致内存泄漏（该回收的没有被回收掉，一直占用着内存，称为内存泄漏）。

### 标记阶段之可达性分析算法

或者叫做根搜索算法、追踪性垃圾收集。

​	所谓的“GC Roots”根集合就是一组必须活跃的引用。

原理：基本思路是通过一系列名为"GC Roots"的对象(集合)作为起点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象是**不可达对象(被回收)**，否则就是可达对象。

![](pics\可达性分析算法之GC Roots.png)

在Java语言中，GC Roots包括以下几类元素：

- (1).虚拟机栈（栈帧中的局部变量表）中的引用对象。比如各个线程被调用的方法中使用到的参数、
      局部变量等。
- (2).本地方法栈中JNI（即一般来说native方法）中引用的对象[ 线程中的start方法 ]
- (3).静态属性引用的对象（比如:Java类的引用类型静态变量）
- (4).方法区中常量引用的对象。比如:字符串常量池（String Table）里的引用。
- (5).所有被synchronized持有的对象
- (6).Java虚拟机内部的引用（基本数据类型对应的Class对象，一些常驻的异常对象[如NullPointerException、OutofMemoryError]，系统类加载器）
- (7).反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
- (8).注意：除了这些固定的GC Roots集合之外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时加入，共同构架完成整GC Roots集合。比如：分代收集和局部回收(==面试加分项==)

**解释**：如果只针对java堆中的某一区域进行垃圾回收(比如: 典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，而不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，此时就需要一并将关联的区域对象也加入到GC Roots 集合中考虑，才能保证可达性分析的准确性。

#### 可达性分析算法的优点

​	相对于引用计数法而言，可达性分析算法不仅同样具备实现简单和执行高效 等特点，更重要的是该算法可以有效解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。

==可达性分析算法的注意事项==：如果要使用可达性分析算法来**判断内存是否可回收**，那么**分析工作必须在 一个能保障一致性的快照中进行**（就是在判断是否可回收时，需要停止其他对象对这些需要判断的对象做引用）。这点不满足的话分析结果的准确性就无法保证。**这点也是导致GC进行时必须“StopThe World"的一个重要原因。**（即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的）

#### 对象的 finalization 机制

​	Java语言提供了对象终止机制来允许开发人员提供对象销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象时，即**回收此对象之前，总会先调用这个对象的finalize()方法。**

​	**==finalize()方法允许在子类中被重写，用于在对象回收之前进行资源释放。==** 通常这个方法中进行一些资源的释放和清理工作，比如关闭文件流、断开套接字和数据库连接等。

​	不要主动调用某个对象的finalize( ) 方法，应该交给垃圾回收机制调用，理由包括下面三点：

- 在finalize( )时可能会导致对象复活；
- finalize( )方法执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize( ) 方法将没有执行机会；
- 一个糟糕的finalize( )会严重影响GC的性能。

==由于finalize()方法的存在，虚拟机中的对象一般处于三种状态==。 如果从所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收，但事实上，**也并非是"非死不可"的**，这时候它们暂时处于"缓刑"阶段。一个无法触及的对象可能在某一个条件下"复活"自己，如果这样，那么对它的回收就是不合理的。为此，定义虚拟机中的对象可能有三种状态。如下：==掌握==

- **可触及的**：从根节点开始,可以到达这个对象；
- **可复活的**：（对象的finalize( )未被调用的情况）对象的所有引用都被释放，但是**对象有可能在finalize( )中复活**；
- **不可触及的**：**对象的finalize( )被调用，并且没有复活，那么就会进入不可触及状态**。不可触及的对象不可能被复活，因为finalize( )只会被调用一次。

==判定一个对象ObjA是否可回收，至少要经历两次标记过程：== 

- 如果对象objA到GC Roots没有引用链，则进行第一标记；
- 进行筛选，判断此对象是否有必要执行finalize()方法
  - **如果对象objA没有重写finalize()方法**，**或者finalize()方法已经被虚拟机调用过**，则虚拟机视为“没有必要执行”，**objA被判定为不可触及的**。
  - **如果对象objA重写了finalize()方法并且未被执行过**，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的低优先级的Finalizer线程触发其finalize()方法执行。
  - **finalize()方法是对象逃脱死亡的最后机会**，稍后GC会对F-Queue队列中的对象**进行第二次标记**。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移除“即将回收”集合。之后，对象会再次出现在没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。

### 垃圾清除阶段

​	当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。

​	目前JVM中比较==常见的三种垃圾收集算法是标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）==。

### 垃圾清除阶段之标记-清除算法

#### 执行过程

​	当堆中的**有效内存空间（available memory）被耗尽时**，就会停止整个程序（**stop the world**），然后进行两项工作：标记和清除。

- 标记：Collector **从引用根节点开始遍历，==标记所有被引用的对象==（即标记的是可达对象，从而就对比出了不可达对象）**。一般是**在对象的Header中记录为可达对象**；
- 清除：Collector **对堆内存从头到尾进行线性的遍历**，如果**发现某个对象在Header中没有标记为可达对象**，则将其**回收**。

#### 优缺点

- 优点是比较常见，易实现；
- 缺点有：
  - 效率不高；
  - 在进行GC的时候，需要停止整个应用程序（STW），
  - 这种方式清除的内存空间是不连续的，容易产生内存碎片。从而需要维护一个空闲列表。

#### 引出问题：何为清除？

​	所谓的**清除并不是真的内存置空**，而是**把需要清除的对象地址保存到空闲列表**（所以又叫做空闲地址列表）里。下次**有新的对象需要加载时，判断垃圾的位置空间是否够，如果够，就直接存放（即覆盖掉原来的数据）**。



### 垃圾清除阶段之复制算法

#### 核心思想， 即原理

​	关键词：一分为二，使用一块，回收时，先复制，在清除，交替使用。

​	**将活着的内存空间分成两块，每次只使用其中一块**，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

#### 优缺点

优点：

- 没有标记和清除过程，实现简单，运行高效；
- 复制过去以后保证空间的连续性，不会出现“碎片”问题。

缺点：

- 需要两倍的内存空间；

  

#### 应用场景

​	新生代的S0和S1区就采用的这种方法。



### 垃圾清除阶段之标记-压缩（或叫做标记-整理）算法

​	**复制算法主要用于新生代中**，因为它的高效性体现在存活对象少，垃圾对象多的情况下。所以说，基于老年代这种：存活对象多，垃圾对象少的情况，就需要使用其他算法。

​	标记-压缩算法是对标记清除算法的改进：因为标记清除算法执行完内存回收后，还会产生内存碎片。

#### 执行过程

- 第一阶段和标记清除算法一样：从根节点开始标记所有被引用对象；
- 第二阶段将所有的存活对象压缩到内存的一端，按顺序摆放。

#### 标记压缩和标记清除算法比较

**==标记-压缩算法的最终效果等同于标记-清除算法执行完成后，在进行一次内存碎片整理。== ** 因此，也称为标记-清除-压缩算法。

二者的本质差异：标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。

对于标记压缩算法：标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。**这样的话，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表开销要小很多**。

#### 优缺点

优点:

​	①. 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可

​	②. 消除了复制算法当中，内存减半的高额代价
缺点:

​	①. 从效率上来说，标记-整理算法要低于复制算法。

​	②. **移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址**。移动过程中，需要全程暂停用户应用程序。即: STW

#### 指针碰撞

​	如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞(Bump the Pointer)。

### 分代收集算法

​	**分代算法是针对对象的不同特征，而使用合适的算法，这里面并没有实际上的新算法产生**。与其说分代收集算法是第五个算法，不如说它是对前三个算法的实际应用，在新生代使用复制算法eden占8分空间，survivor占两个1分，只浪费10%的空闲空间。老年代使用标记-清除/压缩算法清除垃圾。

#### 新生代（Young Gen）

​	**新生代**特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
这种情况**复制算法**的回收整理，速度是最快的。**复制算法的效率只和当前存活对象大小有关**，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过HotSpot中的两个survivor的设计得到缓解。

#### 老年代(Tenured Gen)
​	**老年代**特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
这种情况存在大量存活率高的对象，复制算法明显变得不合适。**一般是由标记-清除或者是标记-清除与标记-整理的混合实现**。

- Mark阶段的开销与存活对象的数量成正比
- Sweep阶段的开销与所管理区域的大小成正相关
- Compact阶段的开销与存活对象的数据量成正比

#### 举例

​	以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep（标记-清除）实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact（标记-整理）算法的Serial Old回收器作为补偿措施：当内存回收效果不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。

### 增量收集（Incremental Collecting）算法

​	对于前面的垃圾收集算法，都有一个通病：在垃圾收集的过程中，应用软件将会处于一种 Stop The World的状态。在STW状态下，应用程序所有的线程都会挂起，等到垃圾回收完成才会继续工作。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。

​	为了解决上面的问题，产生了增量收集算法。

#### 实现思想

​	如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让**垃圾收集线程和应用程序线程交替进行**。==每一次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成。==

​	总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制的工作。

#### 优缺点

优点：

- 弥补了以前的垃圾回收算法由于线程冲突（垃圾回收线程和应用程序线程之间）而引起的STW，从而影响用户体验和系统稳定性。
- 由于垃圾回收过程中，间断性的还执行了应用程序代码，所以能减少系统的停顿时间

缺点：

- 因为线程切换和上下文切换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

### 分区算法

①.一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，**将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿**。

②. 分代和分区的区别：**分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region**；

③. 每一个**小区间都独立使用，独立回收**。这种算法的好处是**可以控制一次回收多少个小区间**。



## 垃圾回收的相关概念

### System.gc()

​	在默认情况下，通过**System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象所占用的空间**。

​	JVM实现者可以通过System.gc()调用来决定JVM的GC行为。一般情况下，垃圾回收应该是自动进行的，无需手动触发，否则就太过于麻烦。 

​	调用System.runFinalization()会强制调用垃圾收集行为，而调用System.gc()（或者叫做Runtime.GetRuntime().gc()）不一定调用垃圾回收。

### 内存溢出（OutOfMemory）

》javadoc文档中对OutOfMemoryError的解释是：**没有空闲内存可用了，并且垃圾回收器也无法提供更多的内存**。

》Java虚拟机堆内存不够的原因：

- Java虚拟机的堆内存设置不够。比如：可能存在内存泄漏问题，很有可能就是**堆的大小不合理**，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数一Xms、一Xmx来调整
- 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）

》==在抛出0utOfMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间==。

- 例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。
- 在java.nio.BIts.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，来清理空间。

》也不是在任何情况下垃圾回收器都会被触发。

- (比如：我们去分配一个超大对象，类似一个超大数组**超过堆的最大值**，**JVM可以判断出垃圾收集并不能解决这个问题**，所以**直接拋出OutOfMemoryError**。

### 内存泄漏（Memory Leak）

》 也称作“存储渗漏”。严格来说，**只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。**

》**广义上的内存泄漏**是指：在实际情况中，很多时候一些不太好的实践（或疏忽）会导致**对象的生命周期变得很长甚至导致OOM**，也可以叫做广泛意义上的“内存泄漏”。

》 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现0utOfMemory异常，导致程序崩溃。

》Java中内存泄漏的8种情况：

- ==单例模式==。**单例的生命周期和应用程序是一样长的**，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。
- *==一些提供close的资源未关闭导致内存泄漏==。比如：**数据库连接**( dataSourse. getConnection())、**网络连接**(socket)和**I/O连接必须手动close**，否则是不能被回收的。
- *==静态集合类==。如：HashMap、LinkedList 等等。如果这些容器为**静态的**，那么它们的**生命周期与JVM程序一致**，则容器中的对象在**程序结束之前将不能被释放**，从而造成内存泄漏。
- ==内部类持有外部类==。如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。
- ==变量不合理的作用域==。一般而言，**一个变量的定义的作用范围大于其使用范围**，很有可能会造成内存泄漏。另一方面，**如果没有及时地把对象设置为null**，很有可能导致内存泄漏的发生。
- ==改变哈希值==。
- *==监听器和回调==。内存泄漏另一个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚，从而导致内存泄漏。

### Stop The World

①. Stop - the - World，简称STW，指的是GC事件发生过程中,会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

②. STW事件和采用哪款GC无关，**所有的GC都有这个事件**。

③. 哪怕是G1也不能完全避免Stop一the一world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。

④. STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。

⑤. **开发中不要用System.gc()，会导致full gc**，会导致Stop一the一world的发生。

⑥. 什么情况下会导致stop the world：

- 可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿
- 进行gc的时候会发生STW现象（调用finalize()方法的时候会暂停用户线程）
  

### 多线程的并行与并发

#### 并发（Concurrent）（在一个CPU上的说法）

》在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。

》**并发**不是真正意义上的“同时进行”，**==只是CPU把一个时间段划分成几个时间片段（时间片），然后在这几个时间区间之间来回切换==**，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。

#### 并行（Parallel）（在多个CPU上的说法）

》当系统有一个以上的CPU时，==当一个CPU（或CPU某一核心）执行一个进程时，另一个CPU（或CPU另一核心）可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，称之为并行==。

》其实，==决定并行的因素不是CPU的数量，而是CPU的核心数量==。比如：**一个CPU多个核，也可以并行**。

#### 垃圾回收的并行、串行、并发

》并行(Parallel)：指**多条垃圾收集线程并行工作**，但此时**用户线程仍处于等待状态**。

》 串行(Serial)

- 相较于并行的概念，**单线程执行**。
- 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。

》并发（Concurrent）

- **指用户线程与垃圾收集线程同时执行**（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。
- 在同一个时间段，用户线程和垃圾回收线程同时执行。

### 安全点（Safe Point）

》程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为 “安全点(Safepoint)”。

》Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。

#### 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？

​	目前，主要采用的方式是：**主动式中断**。设置一个中断标志，**各个线程运行到Safe Point的时候主动轮询这个标志**，如果中断标志为true，则将自己进行中断挂起。

#### 安全区域（Safe Region）

》Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint 。但是，**程序“不执行”的时候呢？例如线程处于Sleep 状态或Blocked状态**，这时候线程无法响应JVM的中断请求，“走” 到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要**安全区域(Safe Region)来解决**。

》**安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的**。我们也可以把Safe Region看做是被扩展了的Safepoint。

》执行过程：

- 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内触发GC，JVM会忽略标识为Safe Region状态的线程；
- 当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待，直到收到可以安全离开SafeRegion的信号为止。

### 引用

引出问题：==【既偏门又非常高频的面试题】==强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？

》在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference) 、弱引用(Weak Reference) 和虚引用(Phantom Reference) 4种，这**4种引用强度依次逐渐减弱**。

》 除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。

》Reference子类中只有**终结器引用**是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用。

简述强、软、弱、虚引用：

- 强引用(StrongReference)：最传统的“引用”的定义，**是指在程序代码之中普遍存在的引用赋值，即类似“0bject obj=new object( )”这种引用关系。** 无论任何情况下，**只要强引用关系还存在**，垃圾收集器就永远**不会回收**掉被引用的对象。**强引用是造成Java内存泄漏的主要原因之一**。
- 软引用(SoftReference)：**在系统将要发生内存溢出之前，会把这些对象列入回收范围之中进行第二次回收**。如果这次回收后还没有足够的内存，才会抛出内存溢出异常 **内存不足即回收**。
  - 软引用通常用来实现内存敏感的缓存；比如：高速缓存就有用到软引用。
  - 当内存足够：不会回收软引用的可达对象；
  - 当内存不够时： 会回收软引用的可达对象。
- 弱引用(WeakReference)：**被弱引用关联的对象只能生存到下一次垃圾收集之前**。当垃圾收集器工作时，**无论内存空间是否足够**，都会回收掉被弱引用关联的对象。**发现即回收**。
- 虚引用(PhantomReference) ：一个对象是否有虛引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。**为一个对象设置虛引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知（回收跟踪）**。虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。
  - 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虛引用中执行和记录。

## 垃圾回收器

### 垃圾回收器有哪些？

​	不同的厂商会考虑使用不同的JVM，不同的JVM会使用不同的垃圾回收器。目前，主流的垃圾回收器有7种，每一款都有不同的特点，简述如下：

|  垃圾回收器  |    分类    |    作用位置    |        使用算法         |     特点     |               适用场景               |
| :----------: | :--------: | :------------: | :---------------------: | :----------: | :----------------------------------: |
|    Serial    |  串行运行  |     新生代     |        复制算法         | 响应速度优先 |    适用于单CPU环境下的client模式     |
|    ParNew    |  并行运行  |     新生代     |        复制算法         | 响应速度优先 |  多CPU环境Server模式下与CMS配合使用  |
|   Parallel   |  并行运行  |     新生代     |        复制算法         |  吞吐量优先  |   适用于后台运算而不需要太多的交互   |
|  Serial Old  |  串行运行  |     老年代     |      标记-压缩算法      | 响应速度优先 |    适用于单CPU环境下的Client模式     |
| Parallel Old |  并行运行  |     老年代     |      标记-压缩算法      |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|     CMS      |  并发运行  |     老年代     |      标记-清除算法      | 响应速度优先 |        适用于互联网或B/S业务         |
|      G1      | 并发、并行 | 新生代、老年代 | 标记-压缩算法、复制算法 | 响应速度优先 |            面向服务端应用            |

==为什么要使用这么多的垃圾回收器？==

​	因为Java程序的使用场景很多，包括移动端和服务端等。一般来说，移动端更看重的是响应时间，而服务端则更看重吞吐量是否达标，所以，针对不同的应用场景，提供不同的垃圾回收器，从而提高垃圾收集的性能。

**查看默认的垃圾回收器**

​	1. -XX:+PrintCommandLineFlags  查看命令行相关参数（包括使用的垃圾回收器）；

​	2. jinfo -flag 相关垃圾回收器参数 进程ID

==JDK 8 默认的垃圾回收器是：Parallel GC和 Parallel Old GC组合。==

==从JDK 9以及以后，默认使用的是：G1 GC。==

### 评估GC的性能指标

- **吞吐量**：运行用户代码中的时间占总运行时间的比例
  - 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)

- **暂停时间**：执行垃圾收集时，程序的工作线程（用户线程）被暂停的时间。
  - 暂停时间有限，意味着尽可能让单次STW的时间短

- 内存占用：Java堆区所占的内存大小

- 垃圾收集开销：吞吐量的补数，**垃圾收集时间与总运行时间的比例**。
- 收集频率：相对于应用程序的执行，收集操作发生的频率

》==现在JVM调优标准：在最大吞吐量优先的情况下，降低停顿时间。==

### 垃圾回收器的组合关系

![](pics\垃圾回收器的组合关系.png)

**图解释**

》两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、 ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；
》其中Serial Old作为CMS 出现"Concurrent Mode Failure"失败的后备预案。
》(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173) ，并在JDK 9中完全取消了这些组合的支持(JEP214)，即：移除。

》(绿色虚线)JDK 14中：弃用Parallel Scavenge和Serial Old GC组合(JEP366 )(青色虚线)，JDK 14中：删除CMS垃圾回收器 (JEP 363)

### Serial、SerialOld 回收器:串行回收  （了解）

- ①. Serial回收器采用**复制算法**、串行回收和 "Stop The World" 机制的方式执行内存回收
- ②. Serial Old回收同样也采用了串行回收 和"Stop the World"机制,**只不过内存回收算法使用的是标记-压缩算法**
- ③. 单线程回收：使用一个CPU或一条线程去完成垃圾回收工作，必须暂停其他所有的工作线程
- ④. 使用 -XX: +UseSerialGC 参数可以指定年轻代和老年代都使用串行回收器。**等价于新生代用Serial GC，且老年代用Serial Old GC**。

### ParNew回收器:并行回收  （了解）

- ①. 如果说Serial GC是年轻代中的单线程垃圾回收器，那么ParNew回收器则是Serial回收器的多线程版本。
- ②. ParNew回收器除了采用并行回收的方式执行内存回收外，两款垃圾回收器之间几乎没有任何区别。ParNew回收器在年轻代中同样也是采用复制算法、"Stop一 the一World"机制。
- ③. 因为除Serial外，目前只有ParNew GC能与CMS回收器配合工作。
- ④. 在程序中，开发人员可以通过选项"-XX:+UseParNewGC"手动指定使用ParNew回收器执行内存回收任务。它表示年轻代使用并行回收器，不影响老年代。
- ⑤. -XX:ParallelGCThreads 限制线程数量。默认开启和CPU数据相同的线程数。

==SerialGC 和 ParNewGC哪个更好?==

​	各有各的好处。ParNew GC运行在多CPU的环境下，而Serial GC使用在单CPU上。

（1）ParNew GC运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量；

（2）但是在单个CPU的环境下，ParNew回收器不比Serial 回收器更高效。虽然Serial回收器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。

### Parallel、Parallel Old特点：吞吐量优先

》HotSpot的年轻代中除了拥有ParNew回收器是基于并行回收的以外， **Parallel 回收器同样也采用了复制算法、并行回收和"Stop the World"机制。**在Java8中，默认使用Parallel和Parallel Old垃圾回收器。

》那么Parallel回收器的出现是否多此一举？

- 和ParNew回收器不同，Parallel Scavenge回收器的目标则是达到一个可控制的吞吐量(Throughput)，它也被称为吞吐量优先的垃圾回收器。而ParNew则是以响应速度优先的。
- 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。

》高吞吐量则可以**高效率地利用CPU时间，尽快完成程序的运算任务**，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：那些执行**批量处理、订单处理、工资支付、科学计算的应用程序**。

》Parallel Old回收器采用了**标记一压缩算法**，但同样也是**基于并行回收和”Stop一the一World"机制**。

》在程序吞吐量优先的应用场景中，Parallel 回收器和Parallel Old回收器的组合，在Server模式下的内存回收性能很不错。



### CMS（Concurrent Mark Sweep，并发标记清除）

#### 概述

①. 在JDK1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾回收器：**CMS (Concurrent Mark Sweep)收集器**，这款回收器是**HotSpot虚拟机中第一款真正意义上的并发回收器**，它第一次实现了让垃圾收集线程与用户线程同时工作。

②. **CMS回收器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间**。停顿时间越短(低延迟)就越适合与用户交互的程序，良好的响应速度能提升用户体验。

③. CMS的垃圾回收算法采用**标记一清除算法**，**并且也会" Stop The World"**。

④. 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。

⑤. CMS收集器在JDK9中被废弃，在JDK14中被移除。

#### CMS执行过程（原理）

- **初始标记**（Initial Mark）。**仅仅只是标记出和GCRoots能直接关联到的对象**，**有STW现象、暂停时间非常短**；
- **并发标记**（Concurrent Mark）阶段。从GC Roots的直接关联对象开始遍历整个对象图的过程，**这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行**（并发标记阶段有三色标记，下文有记录）；
- **重新标记（Remark） 阶段**。有些对象可能开始是垃圾，在并发标记阶段，由于用户线程的影响，导致不是垃圾了，这里需要重新标记的是这部分对象，**这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短**；
- **并发清除**（Concurrent Sweep）。此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于**不需要移动存活对象**，所以这个阶段也是可以与用户线程同时并发的。

![](pics\CMS垃圾回收器的工作原理.png)

==解释：==

》**在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用**。因此，CMS回收器不能像其他回收器那样等到老年代几乎完全被填满了再进行**收集**，而是当堆内存使用率达到某一阈值（使用 **-XX:CMSlnitiatingOccupanyFraction=XXX** 参数设置阈值）时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。**要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败**，这时虚拟机将启动后备预案：临时启用Serial Old回收器来重新进行老年代的垃圾回收，这样停顿时间就很长了。

》**CMS回收器的垃圾回收算法采用的是标记-清除算法**，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，**不可避免地将会产生一些内存碎片**。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞(Bump the Pointer) 技术，而**只能够选择空闲列表(Free List) 执行内存分配**。（浮动垃圾：在并发标记阶段一开始不是垃圾，最后变成了垃圾）

#### CMS优缺点

优点：并发收集垃圾，低延迟；

缺点：

- 会产生内存碎片。采用标记-清除算法，由于在垃圾清理过程中，得到的内存空间极有可能是不连续的，所以**会产生内存碎片**，当然可以用free链表来管理这些不连续的内存空间。
- CMS回收器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为**占用了一部分线程**而导致应用程序变慢，**总吞吐量会降低**。
- CMS回收器无法处理浮动垃圾。可能出现"Concurrent Mode Failure" 失败而导致另一次Full GC的产生。==||== 在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间 ==||==。

注意事项：

为什么需要重新标记？即为什么有重新标记阶段？

​	并发标记阶段，在遍历GCRoots时，用户线程也在执行，若此时遍历过一个对象发现没有引用，但由于用户线程并发执行，**这期间可能导致遍历过的这个对象又被其他对象引用**，**所以才需要重新标记阶段再遍历一次看又没有漏标记的**，否则就会导致被重新引用的对象被清理掉。

#### CMS三色标记概述、问题、解决方案 （了解）

​	在并发标记的过程中，因为**标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生**。这里我们引入“三色标记”来给大家解释下，把GC Roots可达性分析遍历对象过程中遇到的对象，**按照“是否访问过”这个条件标记成以下三种颜色**：

- 黑色：节点被遍历完成，而且子节点都遍历完成；
- 灰色：当前正在遍历的节点，而且子节点还没有遍历；
- 白色：还没有遍历到的节点，即灰色节点的子节点。

![](pics\CMS_三色标记示意图.png)

根据三色扫描算法，如果有下面两种情况发生，则**会出现漏扫描的场景**：

- 把一个白对象的引用存到黑对象的字段里，如果这个情况发生，因为标记为黑色的对象认为是扫描完成的，不会再对他进行扫描。只能通过灰色的对象（CMS垃圾回收器）。如上图中的D如果是白色对象没有引用，某一个时刻由于用户线程的影响，将A黑色对象引用了D的情况，解决办法：使用写屏障和增量更新解决。
- 某个白对象失去了所有能从灰对象到达它的引用路径（直接或间接）（G1垃圾收集器）。如上图中的B灰色对象某一个时刻由于用户线程的影响将B到D的引用置为null，解决办法：使用写屏障和原始快照。

#### 原始快照SATB和增量更新Incremental Update （了解）

》 增量更新(Incremental Update)：在并发标记过程中，**把赋值的这种新增的引用，做一个集合存起来**。在**重新标记阶段会找到集合里面的引用然后重新去扫描，再把源头标记为灰色**。

》在把我们新增的引用放到集合的时候，会实现一种写屏障的方式。在对象前后通过一个dirty card queue将引用信息存放在card中，这个dirty card queue会放在card table中，而card table是记忆集的具体实现，最终这个引用就会放在记忆集中的。

。。。。。。



### G1垃圾回收器

已经存在那么多的垃圾回收器了，**为什么还需要发布Garbage First这样的垃圾回收器**？

​	原因就在于应用程序所对应的业务越来越庞大，复杂，用户越来越多，经常造成STW的GC跟不上实际需求。从而有了G1垃圾回收器，**它以极高的概率满足GC停顿时间的同时，还兼备高吞吐量的性能。**官方给G1设定的目标是：**在延迟可控的情况下获得尽可能高的吞吐量**，所以才担当起"全功能收集器"的重任与期望。

#### 概述

》G1（Garbage First）是一款面向服务端应用程序的垃圾回收器。主要针对配备多核CPU以及大容量内存的机器。**以极高的概率满足GC停顿时间的同时，还兼备高吞吐量的性能**（使用G1的原因）。

》JDK 9 以后的默认垃圾回收器改为G1（之前默认的是Parallel和Parallel Old垃圾回收器）。

》为什么叫做Garbage First？

- G1是一个并行回收器，它把堆内存分割为很多不相关的区域（region物理上不连续），把堆分为2048个区域，每一个region的大小是1 - 32M不等，必须是2的整数次幂。使用不同的region可以来表示新生代（Eden、幸存者0区、幸存者1区）、老年代等。
- 每次根据允许的收集时间，优先回收价值最大的Region。每次回收完以后都有一个空闲的region，通过在后台维护一个优先列表来记录这个空闲region的位置。
- 由于这种方式的侧重点在于回收垃圾最大量的区间(Region)，所以我们给G1一个名字：垃圾优先(Garbage First)。

![](pics\G1回收器内存划分示意图.png)

#### G1的优缺点

**特点：**

》并行与并发

- 并行：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
- 并发：G1拥有与应用程序交替执行的能力，**部分工作可以和应用程序同时执行**，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。

》分代收集

- 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
- 将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。
- 和之前的各类回收器不同，它同时兼顾年轻代和老年代。

》空间整合

​	G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。**Region之间是复制算法，但整体上实际可看作是标记一压缩(Mark一Compact)算法，两种算法都可以避免内存碎片**。这种特性**有利于程序长时间运行**，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

》可预测的停顿时间（响应时间）模型（即软实时 soft real-time）

​	这是 G1 相对于 CMS 的另一大优势：G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。可以通过参数-XX:MaxGCPauseMillis进行设置。

**优点**

（1）**由于分区的原因，G1可以只选取部分区域进行内存回收**，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制；

（2）G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，**优先回收价值最大的Region**。保证了G1收集器**在有限的时间内可以获取尽可能高的收集效率。**

（3）相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

**缺点**

（1）相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载(Overload)都要比CMS高。

（2）从经验上来说，**在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势**。平衡点在6-8GB之间。

#### 调优操作步骤

》G1的设计原理就是简化JVM性能调优，开发人员只需要简单的三步就可以完成调优：

- 开启G1垃圾回收器；
- 设置堆的最大内存；
- 设置最大的停顿时间。

》G1中提供了三种垃圾回收模式：Young GC、Mixed GC和Full GC。在不同的条件下被触发。



#### Region详解

》使用G1收集器时，它将整个Java堆划分成**约2048个大小相同的独立Region块**，每个Region块大小根据堆空间的实际大小而定，整体被控制**在1MB到32MB之间**，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过-XX:G1HeapRegionSize来设定。一旦设置，所有的Region大小相同，且在JVM生命周期内不会改变。

》一个region 有可能属于Eden，Survivor 或者Old/Tenured 内存区域。但是一个region只可能属于一个角色。图中的E表示该region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。

》 垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1. 5个region，就放到H块中。

==对于H区的理解：==

​	对于**堆中的大对象，默认直接会被分配到老年代**，但是如果它是一个**短期存在的大对象**，就会对垃圾收集器造成负面影响。为了解决这个问题，**G1划分了一个Humongous区，它用来专门存放大对象**。如果**一个H区装不下**一个大对象，那么G1会**寻找连续的H区来存储**。**为了能找到连续的H区，有时候不得不启动Full GC**。G1的大多数行为都把**H区作为老年代的一部分来看待**。

#### 记忆集 Remembered Set 与写屏障 Write Barrier

》抛出问题：一个Region不可能是孤立的，一个Region中的对象可能被其他对象引用，如新生代中引用了老年代，这个时候垃圾回收时，会去扫描老年代，出现STW。

》做出解答：无论是G1还是分代回收器，**JVM都是使用Remembered Set来避免全局扫描**。**每个Region都有一个对应的Remembered Set。**==（掌握）==

- 每次Reference类型数据写操作时，都会产生一个Write Barrier暂停时间；
- 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；
- 如果不同，**通过CardTable**把相关引用信息记录到引用**指向对象的所在Region对应的Remembered Set中**；
- 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。

#### G1回收器的垃圾回收过程

》**主要包括**三个环节：

1. 年轻代GC (Young GC)
2. 老年代并发标记过程 (Concurrent Marking)
3. 混合回收(Mixed GC)
4. 如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败的保护机制，即强力回收。

示意图解释：顺时针，young gc -> young gc + concurrent mark-> Mixed GC顺序，进行垃圾回收。

<img src="pics\G1 GC垃圾回收过程.png" style="zoom: 67%;" />



> 过程解释：

（1）应用程序分配内存，当年轻代的Eden区用尽时，开始年轻代回收过程。**G1的年轻代收集阶段是一个并行(多个垃圾线程)的独占式收集器。**==在年轻代回收期间，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收==。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及；

（2）**当堆内存使用达到一定值（默认45%）时**，开始老年代**并发标记过程**；

（3）**标记完成马上开始混合回收过程。**对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。**和年轻代不同，老年代的G1回收器和其他GC不同**，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。**同时，这个老年代Region是和年轻代一起被回收的。**

#### 回收过程之年轻代GC

》回收时机

- (1). 当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程；
- (2). **年轻代垃圾回收只会回收Eden区和Survivor区。**

》回收过程

- **（GC Roots）根扫描**（这里的根更多的是指static变量以及栈中的局部变量）：一定要考虑Remembered Set，看是否有老年代中的对象引用了新生代对象；

- **更新RSet**：处理dirty card queue中的card，更新RSet。 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用；

  ​	什么是dirty card queue？对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在**dirty card queue中入队一个保存了对象引用信息的card**。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。**那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多**。

- **处理RSet**：识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象；
- **复制对象**：使用复制算法。此阶段，对象树被遍历，**Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段**，**Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被复制到Old区中空的内存分段。**如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。
-  **处理引用**：处理Soft，Weak，Phantom，Final，JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。



#### 回收过程之并发标记过程

①. **初始标记阶段**：标记从根节点直接可达的对象。这个阶段是STW的，并且会**触发一次年轻代GC**；

②. **根区域扫描**(Root Region Scanning)：**G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象**。这一过程必须在Young GC之前完成（原因：Young GC时，会对Survivor区有所操作，所以这一过程必须在Young GC之前完成）；

③. **并发标记**(Concurrent Marking)：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。在并发标记阶段，**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）；

④. **再次标记**（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。会STW的。G1中采用了比CMS更快的初始快照算法 (SATB：snapshot at the beginning)；

⑤. **独占清理**（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，**识别可以混合回收的区域**。为下阶段做铺垫。是STW的。**这个阶段并不会实际去做垃圾的收集**

⑥. **并发清理阶段**：**识别**并清理完全空闲的区域。



#### 回收过程之混合回收 Mixed GC

①. Mixed GC并不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercent)设定的值则触发，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区，正常情况G1的垃圾收集是先做**MixedGC，主要使用复制算法，**需要把各个region中存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC。



#### 回收过程触发Full GC的原因

①. **堆内存过小**，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到full gc。解决办法：这种情况可以通过增大内存解决。

②. **暂停时间-XX:MaxGCPauseMillis设置短，回收频繁**。由于用户线程和GC线程一起执行，可能用户线程产生的垃圾大于GC线程回收的垃圾，会导致内存不足，触发Full GC。

























































































































































































































































































































































































































































































































+++++++++++++++++
